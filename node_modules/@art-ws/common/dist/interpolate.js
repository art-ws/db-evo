"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterpolateObject = exports.iterpolate = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const e = {
    RE: /{{(\w|\.)+}}/gi,
    B: "{{",
    E: "}}",
};
const isEmpty = (v) => v === undefined || v === null || Number.isNaN(v);
function iterpolate(vars, template) {
    let tpl = template;
    let n = 0;
    const MAX_CYCLES = 100;
    while (true) {
        n++;
        const s = tpl;
        const keys = {};
        let match;
        while ((match = e.RE.exec(tpl))) {
            let s = match[0];
            s = s.substring(e.B.length, s.length - e.E.length);
            keys[s] = true;
        }
        Object.keys(keys).forEach((key) => {
            const expr = e.B + key + e.E;
            const val = lodash_1.default.get(vars, key);
            const value = isEmpty(val) ? expr : `${val}`;
            tpl = tpl.split(expr).join(value);
        });
        if (s === tpl)
            break;
        if (!isInterpolationRequired(tpl))
            break;
        if (n > MAX_CYCLES)
            break;
    }
    return tpl;
}
exports.iterpolate = iterpolate;
function isInterpolationRequired(s) {
    return s && typeof s === "string" && s.includes(e.B) && s.includes(e.E);
}
const walk = (o, fn, depth, parentPath) => {
    if (!o)
        return;
    Object.keys(o).forEach((key) => {
        if (typeof o[key] === "object") {
            walk(o[key], fn, depth + 1, [...parentPath, key]);
        }
        else {
            fn(o, key, parentPath);
        }
    });
};
function iterpolateObject(data, vars) {
    if (vars) {
        vars = iterpolateObject(vars);
    }
    else {
        vars = data;
    }
    const interpolateKeys = () => {
        walk(data, (o, key) => {
            if (isInterpolationRequired(key)) {
                const newKey = iterpolate(vars, key);
                const val = o[key];
                delete o[key];
                o[newKey] = val;
            }
        }, 0, []);
    };
    const interpolateValues = () => {
        walk(data, (o, key) => {
            const val = o[key];
            if (isInterpolationRequired(val)) {
                const newVal = iterpolate(vars, val);
                o[key] = newVal;
            }
        }, 0, []);
    };
    interpolateKeys();
    interpolateValues();
    return data;
}
exports.iterpolateObject = iterpolateObject;
//# sourceMappingURL=interpolate.js.map