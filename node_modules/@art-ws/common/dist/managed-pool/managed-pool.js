"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManagedPool = exports.DEFAULT_TIME_TO_IDLE = void 0;
const slf_1 = require("@art-ws/slf");
exports.DEFAULT_TIME_TO_IDLE = 2 * 60 * 1000;
class ManagedPool {
    constructor(adapter, cache) {
        this.adapter = adapter;
        this.cache = cache;
        this.logger = slf_1.getLogger(ManagedPool);
        const canRemove = (item) => this.adapter.canDestroy(item);
        const onRemove = (item) => {
            this.adapter.destroy(item);
        };
        const opts = this.adapter.getCacheOptions();
        opts.timeToIdle = opts.timeToIdle || exports.DEFAULT_TIME_TO_IDLE;
        this.poolCacheOptions = { ...opts, onRemove, canRemove };
    }
    async acquire(args) {
        const ID = this.adapter.ID(args);
        this.logger.trace(() => [`acquire(${ID})`]);
        const item = await this.cache.getOrUpdateAsync(ID, async () => {
            this.logger.trace(() => [`create new(${ID})`]);
            return this.adapter.create(args);
        }, this.poolCacheOptions);
        return item;
    }
    async acquireManaged(args) {
        const item = await this.acquire(args);
        const mc = {
            item,
            release: () => {
                const ID = this.adapter.ID(args);
                this.logger.trace(`release(${ID})`);
                // this will call item.onRemove() which in turn calls adapter.destroy()
                this.cache.removeItem(ID, null, true);
            },
        };
        return mc;
    }
    close() {
        this.cache.clear();
    }
}
exports.ManagedPool = ManagedPool;
//# sourceMappingURL=managed-pool.js.map