"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Zone = void 0;
const tslib_1 = require("tslib");
const async_hooks_1 = tslib_1.__importDefault(require("async_hooks"));
// inspired by https://raw.githubusercontent.com/JsCommunity/node-zone/master/index.js
// https://nodejs.org/api/async_hooks.html#async_hooks_init_asyncid_type_triggerasyncid_resource
// https://dzone.com/articles/beware-the-performance-cost-of-async-hooks-node-8
// https://github.com/bmeurer/async-hooks-performance-impact
const zones = Object.create(null);
let current;
const asyncHook = async_hooks_1.default.createHook({
    init(uid) {
        zones[uid] = current;
    },
    before(uid) {
        current = zones[uid];
        // it appears `init` is not called when using the `cluster` module,
        // therefore `zones[uid]` might not exist in `before`
        //
        // Work-around: set the current zone to the root zone, it's incorrect but it
        // allows using root data and create new zones by forking.
        //
        // see https://github.com/JsCommunity/node-zone/issues/3
        if (current === undefined) {
            current = root;
        }
    },
    destroy(uid) {
        delete zones[uid];
    },
});
let asyncHooksEnabled = null;
const toggleAsyncHooks = (value) => {
    if (value === asyncHooksEnabled) {
        return;
    }
    asyncHooksEnabled = value;
    if (asyncHooksEnabled) {
        asyncHook.enable();
    }
    else {
        asyncHook.disable();
    }
};
class Zone {
    constructor(parent, spec) {
        this.zoneData = Object.create(null);
        this.zoneName = "root";
        this.zoneParent = null;
        toggleAsyncHooks(true);
        if (parent !== null) {
            const data = (this.zoneData = Object.create(parent.data));
            this.zoneParent = parent;
            let name = "";
            if (typeof spec === "string") {
                name = spec;
            }
            else if (spec !== null) {
                name = spec.name;
                const { properties } = spec;
                if (properties) {
                    for (const key in properties) {
                        if (properties.hasOwnProperty(key)) {
                            data[key] = properties[key];
                        }
                    }
                }
            }
            this.zoneName = name || `${parent.name} child`;
        }
    }
    get data() {
        return this.zoneData;
    }
    get name() {
        return this.zoneName;
    }
    get parent() {
        return this.zoneParent;
    }
    fork(spec) {
        return new Zone(this, spec);
    }
    run(callback, thisArg, args) {
        const previous = current;
        try {
            current = this;
            return callback.apply(thisArg ?? null, args ?? []);
        }
        finally {
            current = previous;
        }
    }
    wrap(callback) {
        const { run: wrapper } = this;
        // https://stackoverflow.com/questions/41944650/this-implicitly-has-type-any-because-it-does-not-have-a-type-annotation
        return function (...args) {
            return wrapper(callback, this, args);
        };
    }
    static isEnabled() {
        return Boolean(asyncHooksEnabled);
    }
    static enable() {
        toggleAsyncHooks(true);
    }
    static disable() {
        toggleAsyncHooks(false);
    }
    // minimal zone.js compatibility
    get(key) {
        return this.zoneData[key] || null;
    }
    getZoneWith(key) {
        if (Object.prototype.hasOwnProperty.call(this.zoneData, key)) {
            return this;
        }
        const parent = this.zoneParent;
        return parent && parent.getZoneWith(key);
    }
    static get current() {
        return current;
    }
}
exports.Zone = Zone;
const root = (current = new Zone(null, null));
//# sourceMappingURL=node-zone.js.map