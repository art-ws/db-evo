"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = exports.AssertDSL = void 0;
class AssertDSL {
    constructor(args) {
        this.name = "";
        if (typeof args === "object") {
            const keys = Object.keys(args);
            if (keys.length === 1) {
                this.name = keys[0];
                this.value = args[this.name];
            }
            else {
                this.value = args;
            }
        }
        else {
            this.value = args;
        }
        this.name = this.name || "value";
    }
    defined(message) {
        if (!this.value)
            throw new Error(message || `${this.name} not defined`);
        return this;
    }
    truthly(message) {
        if (!this.value)
            throw new Error(message || `${this.name} not truthly`);
        return this;
    }
    range(a, b) {
        if (!(a <= this.value && b >= this.value))
            throw new Error(`Number ${this.value} must be in range [${a}, ${b}]`);
        return this;
    }
    intLike() {
        return this.int(true);
    }
    int(compatible) {
        let candidate = this.value;
        if (compatible) {
            candidate = parseInt(candidate) || candidate;
        }
        if (!Number.isInteger(candidate))
            throw new Error(`${this.name} is '${`${candidate}`}', but not an integer number`);
        return this;
    }
    typeOf(typeName) {
        const t = typeof this.value;
        if (t !== typeName)
            throw new Error(`${this.name} is not an ${typeName}, but '${t}'`);
        return this;
    }
    func() {
        return this.typeOf("function");
    }
    object() {
        return this.typeOf("object");
    }
    str() {
        return this.string();
    }
    anyOf(values) {
        const k = (values || []).findIndex((x) => this.value === x);
        if (k === -1)
            throw new Error(`${this.name} = '${this.value}' not one of ${JSON.stringify(values)}`);
        return this;
    }
    string() {
        return this.typeOf("string");
    }
    hasProps(props) {
        ;
        (props || []).forEach((prop) => {
            if (!this.value.hasOwnProperty(prop))
                throw new Error(`Property ${this.name}.${prop} not defined`);
        });
        return this;
    }
    array() {
        if (!Array.isArray(this.value))
            throw new Error(`${this.name} is not an array`);
        return this;
    }
    arrayOf(props) {
        this.array();
        this.value.forEach((it) => {
            ;
            (props || []).forEach((prop, i) => {
                if (!it.hasOwnProperty(prop))
                    throw new Error(`Property ${this.name}[${i}].${prop} not defined`);
            });
        });
        return this;
    }
    notEmpty() {
        if (this.value === null ||
            this.value === undefined ||
            (typeof this.value === "number" && isNaN(this.value))) {
            throw new Error(`Property ${this.name} is empty`);
        }
        if (Array.isArray(this.value) && !this.value.length)
            throw new Error(`Array ${this.name} is empty`);
        return this;
    }
    null() {
        if (this.value !== null)
            throw new Error(`${this.name} must be null, but it equals to ${this.value}.`);
        return this;
    }
    validJSON() {
        try {
            JSON.parse(this.value);
        }
        catch (e) {
            throw new Error(`${this.name} is not valid JSON.`);
        }
        return this;
    }
    likeJSON() {
        if (typeof this.value === "string") {
            this.validJSON();
        }
        else if (!(this.value instanceof Object)) {
            throw new Error(`${this.name} must be either JSON-encoded string or an object`);
        }
        return this;
    }
    as(name) {
        this.name = name;
        return this;
    }
    eq(value) {
        if (this.value !== value)
            throw new Error(`${this.name} must equals '${value}', but it equals to ${this.value}.`);
        return this;
    }
}
exports.AssertDSL = AssertDSL;
function assert(arg) {
    return new AssertDSL(arg);
}
exports.assert = assert;
//# sourceMappingURL=assert-dsl.js.map